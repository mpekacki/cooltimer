{"version":3,"sources":["App.js","serviceWorker.js","DefaultSettings.js","Settings.js","BrowserNotifications.js","LocalStorage.js","index.js"],"names":["App","props","onClickStartWorking","setStateAndStorage","isWork","timerRunning","onClickReturnToWork","timerSeconds","settings","workMinutes","onClickGoOnABreak","availableBreakSeconds","Math","round","state","tick","newState","newTimerSeconds","newTotalWorkedSeconds","totalWorkedSeconds","availableBreakSecondsIncrement","shortBreakMinutes","hiddenAvailableBreakSeconds","newAvailableBreakSeconds","onTimerFinish","newIsWork","newCycle","cycle","longBreakFreq","longBreakMinutes","continousWork","notifications","notificationsGranted","notificationTitle","createNotification","onClickHoldWork","onClickResumeWork","onChangeContinousWork","event","target","checked","setState","storage","Object","assign","setInterval","requestPermission","then","result","seconds","minutesPart","floor","length","secondsPart","hoursPart","hoursLabel","className","Helmet","this","formatSecondsAsTimer","rel","href","integrity","crossorigin","onClick","formatSecondsAsText","type","value","data-testid","onChange","React","Component","Boolean","window","location","hostname","match","DefaultSettings","workDayMinutes","_workMinutes","_shortBreakMinutes","_longBreakMinutes","_longBreakFreq","_workDayMinutes","BrowserNotifications","Notification","title","params","LocalStorage","JSON","parse","localStorage","getItem","setItem","stringify","ReactDOM","render","basename","process","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.c8f61044.chunk.js","sourcesContent":["import React from 'react';\r\nimport { Helmet } from 'react-helmet';\r\nimport './App.css';\r\n\r\nclass App extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.settings = props.settings;\r\n    this.storage = props.storage;\r\n    if (this.storage && this.storage.state) {\r\n      this.state = this.storage.state;\r\n    } else {\r\n      this.state = {\r\n        timerSeconds: props.settings.workMinutes * 60,\r\n        totalWorkedSeconds: 0,\r\n        isWork: null,\r\n        availableBreakSeconds: 0,\r\n        hiddenAvailableBreakSeconds: 0,\r\n        cycle: 0,\r\n        notificationsGranted: false,\r\n        timerRunning: null,\r\n        continousWork: false\r\n      };\r\n    }\r\n    setInterval(this.tick, 1000);\r\n    if (props.notifications) {\r\n      this.notifications = props.notifications;\r\n      this.notifications.requestPermission().then((result) => {\r\n        if (result === 'granted') {\r\n          this.notificationsGranted = true;\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  formatSecondsAsTimer(seconds) {\r\n    let minutesPart = Math.floor(seconds / 60) + '';\r\n    if (minutesPart.length === 1) {\r\n      minutesPart = '0' + minutesPart;\r\n    }\r\n    let secondsPart = (seconds % 60) + '';\r\n    if (secondsPart.length === 1) {\r\n      secondsPart = '0' + secondsPart;\r\n    }\r\n    return minutesPart + ':' + secondsPart;\r\n  }\r\n\r\n  formatSecondsAsText(seconds) {\r\n    seconds = Math.round(seconds);\r\n    let hoursPart = Math.floor(seconds / 3600) + '';\r\n    let hoursLabel = hoursPart === '1' ? 'hour' : 'hours';\r\n    seconds = seconds % 3600;\r\n    let minutesPart = Math.floor(seconds / 60) + '';\r\n    let minutesLabel = minutesPart === '1' ? 'minute' : 'minutes';\r\n    seconds = seconds % 60;\r\n    let secondsPart = (seconds % 60) + '';\r\n    let secondsLabel = secondsPart === '1' ? 'second' : 'seconds';\r\n    return hoursPart + ' ' + hoursLabel + ' ' + minutesPart + ' ' + minutesLabel + ' ' + secondsPart + ' ' + secondsLabel + ' ';\r\n  }\r\n\r\n  onClickStartWorking = () => {\r\n    this.setStateAndStorage({\r\n      isWork: true,\r\n      timerRunning: true\r\n    });\r\n  }\r\n\r\n  onClickReturnToWork = () => {\r\n    this.setStateAndStorage({\r\n      isWork: true,\r\n      timerSeconds: this.settings.workMinutes * 60\r\n    });\r\n  }\r\n\r\n  onClickGoOnABreak = () => {\r\n    let availableBreakSeconds = Math.round(this.state.availableBreakSeconds);\r\n    this.setStateAndStorage({\r\n      isWork: false,\r\n      timerSeconds: availableBreakSeconds,\r\n      availableBreakSeconds: availableBreakSeconds\r\n    });\r\n  }\r\n\r\n  tick = () => {\r\n    if (!this.state.timerRunning) {\r\n      return;\r\n    }\r\n\r\n    let newState = {};\r\n    let newTimerSeconds = this.state.timerSeconds - 1;\r\n    newState.timerSeconds = newTimerSeconds;\r\n    if (this.state.isWork) {\r\n      let newTotalWorkedSeconds = this.state.totalWorkedSeconds + 1;\r\n      newState.totalWorkedSeconds = newTotalWorkedSeconds;\r\n      let availableBreakSecondsIncrement = this.settings.shortBreakMinutes * 1.0 / this.settings.workMinutes;\r\n      if (this.state.availableBreakSeconds >= this.settings.shortBreakMinutes * 60) {\r\n        newState.availableBreakSeconds = this.state.availableBreakSeconds + availableBreakSecondsIncrement;\r\n      } else {\r\n        newState.hiddenAvailableBreakSeconds = this.state.hiddenAvailableBreakSeconds + availableBreakSecondsIncrement;\r\n      }\r\n    } else {\r\n      let newAvailableBreakSeconds = this.state.availableBreakSeconds - 1;\r\n      newState.availableBreakSeconds = newAvailableBreakSeconds;\r\n    }\r\n    this.setStateAndStorage(newState);\r\n    if (newTimerSeconds === 0) {\r\n      this.onTimerFinish();\r\n    }\r\n  }\r\n\r\n  onTimerFinish = () => {\r\n    let isWork = this.state.isWork;\r\n    if (isWork) {\r\n      let newCycle = this.state.cycle + 1;\r\n      let newAvailableBreakSeconds = this.state.availableBreakSeconds;\r\n      if (newCycle === this.settings.longBreakFreq) {\r\n        newCycle = 0;\r\n        newAvailableBreakSeconds += this.settings.longBreakMinutes * 60 - this.settings.shortBreakMinutes * 60;\r\n      }\r\n      newAvailableBreakSeconds += this.state.hiddenAvailableBreakSeconds;\r\n      newAvailableBreakSeconds = Math.round(newAvailableBreakSeconds);\r\n\r\n      let newTimerSeconds;\r\n      let newIsWork;\r\n\r\n      if (this.state.continousWork) {\r\n        newTimerSeconds = this.settings.workMinutes * 60;\r\n        newIsWork = true;\r\n      } else {\r\n        newTimerSeconds = newAvailableBreakSeconds;\r\n        newIsWork = false;\r\n      }\r\n\r\n      this.setStateAndStorage({\r\n        timerSeconds: newTimerSeconds,\r\n        availableBreakSeconds: newAvailableBreakSeconds,\r\n        hiddenAvailableBreakSeconds: 0,\r\n        isWork: newIsWork,\r\n        cycle: newCycle\r\n      });\r\n    } else {\r\n      this.setStateAndStorage({\r\n        timerSeconds: this.settings.workMinutes * 60,\r\n        isWork: true\r\n      });\r\n    }\r\n\r\n    if (this.notifications && this.notificationsGranted) {\r\n      let notificationTitle = isWork ? 'Work finished' : 'Break finished';\r\n      this.notifications.createNotification(notificationTitle);\r\n    }\r\n  }\r\n\r\n  onClickHoldWork = () => {\r\n    this.setStateAndStorage({\r\n      timerRunning: false\r\n    });\r\n  }\r\n\r\n  onClickResumeWork = () => {\r\n    this.setStateAndStorage({\r\n      timerRunning: true\r\n    });\r\n  }\r\n\r\n  onChangeContinousWork = (event) => {\r\n    this.setStateAndStorage({\r\n      continousWork: event.target.checked\r\n    });\r\n  }\r\n\r\n  setStateAndStorage = (state) => {\r\n    this.setState(state);\r\n    if (this.storage) {\r\n      this.storage.state = Object.assign(this.state, state);\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"App\">\r\n        <Helmet>\r\n          <title>{this.formatSecondsAsTimer(this.state.timerSeconds)}</title>\r\n        </Helmet>\r\n\r\n        <link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css\" integrity=\"sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T\" crossorigin=\"anonymous\"></link>\r\n        {this.state.timerRunning === true &&\r\n          <button className=\"btn btn-warning\" onClick={ this.onClickHoldWork }>Hold work</button>\r\n        }\r\n        {this.state.timerRunning === false &&\r\n          <button className=\"btn btn-secondary\" onClick={ this.onClickResumeWork }>Resume work</button>\r\n        }\r\n        {this.state.isWork === null &&\r\n          <button className=\"btn btn-success\" onClick={ this.onClickStartWorking }>Start working</button>\r\n        }\r\n        <br/>\r\n        <h1>{this.formatSecondsAsTimer(this.state.timerSeconds)}</h1>\r\n        {(this.state.isWork === true && this.state.availableBreakSeconds) ? \r\n          <>\r\n            <button className=\"btn btn-success\" onClick={ this.onClickGoOnABreak }>Go on a break</button>\r\n            <br/>\r\n          </> : null\r\n        }\r\n        {this.state.isWork === false ?\r\n          <>\r\n            <button className=\"btn btn-secondary\" onClick={ this.onClickReturnToWork }>Return to work</button>\r\n            <br/>\r\n          </> : null\r\n        }\r\n        {this.formatSecondsAsText(this.state.totalWorkedSeconds)}<br/>\r\n        {this.formatSecondsAsText(this.state.availableBreakSeconds)}<br/>\r\n        <input \r\n          type=\"checkbox\" \r\n          value=\"Continuous work\" \r\n          data-testid=\"cont-work\" \r\n          onChange={ this.onChangeContinousWork } \r\n          checked={ this.state.continousWork }/> Continuous work\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import Settings from './Settings';\r\n\r\nclass DefaultSettings extends Settings {\r\n  constructor() {\r\n    super(25, 5, 10, 4, 480);\r\n  }\r\n}\r\n\r\nexport default DefaultSettings;","class Settings {\r\n    constructor(workMinutes, shortBreakMinutes, longBreakMinutes, longBreakFreq, workDayMinutes) {\r\n        this._workMinutes = workMinutes;\r\n        this._shortBreakMinutes = shortBreakMinutes;\r\n        this._longBreakMinutes = longBreakMinutes;\r\n        this._longBreakFreq = longBreakFreq;\r\n        this._workDayMinutes = workDayMinutes;\r\n    }\r\n\r\n    get workMinutes() {\r\n        return this._workMinutes;\r\n    }\r\n\r\n    get shortBreakMinutes() {\r\n        return this._shortBreakMinutes;\r\n    }\r\n\r\n    get longBreakMinutes() {\r\n        return this._longBreakMinutes;\r\n    }\r\n\r\n    get longBreakFreq() {\r\n        return this._longBreakFreq;\r\n    }\r\n\r\n    get workDayMinutes() {\r\n        return this._workDayMinutes;\r\n    }\r\n}\r\n\r\nexport default Settings;","class BrowserNotifications {\r\n    requestPermission() {\r\n        return Notification.requestPermission();\r\n    }\r\n\r\n    createNotification(title, params) {\r\n        new Notification(title, params);\r\n    }\r\n}\r\n\r\nexport default BrowserNotifications;","class LocalStorage {\r\n    constructor() {\r\n    }\r\n    \r\n    get state() {\r\n        return JSON.parse(localStorage.getItem('timer_state'));\r\n    }\r\n\r\n    set state(state) {\r\n        localStorage.setItem('timer_state', JSON.stringify(state));\r\n    }\r\n}\r\n\r\nexport default LocalStorage;","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\nimport DefaultSettings from './DefaultSettings';\r\nimport BrowserNotifications from './BrowserNotifications';\r\nimport LocalStorage from './LocalStorage';\r\n\r\nReactDOM.render(<App basename={ process.env.PUBLIC_URL } settings={ new DefaultSettings() } notifications={ new BrowserNotifications() } storage={ new LocalStorage() }/>, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}